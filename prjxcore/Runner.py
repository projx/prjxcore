import subprocess, os
import traceback
from abc import ABC, abstractmethod
from prjxcore.AppLog import *
from prjxcore.Base import *

class BaseCMD(Base):
    """
    Base class, used to define the interface for a command which ran by the CMDRunner class.

    Primary function is get_runnable(), which returns a list of strings that can be passed to subprocess.run()
    """
    # stdout = ""
    # stderr = ""
    # ran_call = ""
    # code = ""
    def __init__(self):
        pass
    
    def internal_call(self):
        return False
    
    @abstractmethod
    def run_func(self):
        pass


    @abstractmethod
    def get_cmd(self):
        pass

    @abstractmethod
    def get_args(self):
        pass

    @abstractmethod
    def get_runnable(self):
        pass


    @abstractmethod
    def prerequisites(self, initiator):
        pass




class CMDRunner(Base):
    """
    Class executes shell commands, these are generated by the BaseCMD class.
    """

    stdout = None
    stderr = None
    results = None
    code = None
    generated_call = None
    ran_call = None

    def __init__(self):
        pass

    def get_stdout(self)->str:
        """
        Return the stdout from the last run
        :return:
        """
        return self.stdout

    def get_stderr(self)->str:
        """
        Return the stderr from the last run
        :return: str
        """
        return self.stderr

    def run(self, cmd : BaseCMD, taskname : str, abort_on_error=True, is_dryrun=False) -> bool:
        """
        Run a command, and return the results.
        :param cmd:
        :param taskname:
        :param abort_on_error:
        :param is_dryrun:
        :return:
        """
        try:
            applog.info("Runner: Begin {}".format(taskname))
            self.generated_call = cmd.get_runnable()

            if is_dryrun == False:
                applog.debug("Runner: Executing now\n{}".format(self.generated_call))
                if cmd.internal_call():
                    self.result = cmd.run_func()
                    self.stdout = "This was an internal function call (no subprocess)"
                    self.stderr = ""
                    self.ran_call = "This was an internal function call (no subprocess)"
                    self.code = 0
                else:
                    results = subprocess.run(self.generated_call, capture_output = True, text=True, check=True, shell=True)
                    self.stdout = results.stdout
                    self.stderr = results.stderr
                    self.ran_call = results.args
                    self.code = results.returncode
            else:
                applog.debug("Runner: Dryrun is enabled, skipping execution")
                return True


            return True

        except subprocess.CalledProcessError as e:
            applog.error("*********************************************************************")
            applog.error("Runner Command: %s" % e)
            applog.error("*********************************************************************")
            applog.error("Runner Error: %s" % e.stderr)
            applog.error("*********************************************************************")
            applog.debug("Stack Trace: ")
            applog.debug("*********************************************************************")


            applog.info("Runner: If debug is enabled, the stack trace is below:")
            applog.debug(traceback.format_exc())
            self.trace =  traceback.format_exc()
            self.stdout = e.stdout
            self.stderr = e.stderr
            self.code = e.returncode
            self.ran_call = e.args
            if abort_on_error:
                applog.info("Runner: Task has Abort On Error set to True, Exiting...")
                raise
            else:
                applog.info("Runner: Task has Abort On Error set to False, continuing")
                return False

